package elk

import (
	"encoding/json"
	"fmt"
	"os"
	"regexp"
	"strings"
	"time"

	"github.com/byuoitav/common/log"
	"github.com/byuoitav/common/nerr"
	ei "github.com/byuoitav/common/v2/events"
)

type saltEvent struct {
	Tag  string                 `json:"tag"`
	Data map[string]interface{} `json:"data"`
}

//converts salt events to API events
func translate(jsonString string) (ei.Event, *nerr.E) {

	//unmarshal into the generic structure so we can check the tag
	var event saltEvent
	err := json.Unmarshal([]byte(jsonString), &event)
	if err != nil {
		log.L.Debugf("Error unmarshaling event into generic structure [%v] [%v]", jsonString, err.Error())
		return ei.Event{}, nerr.Create("Could not translate event! Error unmarshaling.", "UnrecognizedJSON")
	}

	becaonStatus := regexp.MustCompile(`(\/beacon).*(\/status)`)
	chromium := regexp.MustCompile(`(\/beacon).*(\/ps).*(chromium)`)
	change := regexp.MustCompile(`(\/presence)(\/change)`)
	//docker := regexp.MustCompile(`(\/beacon)(\/ps)(docker)`)

	log.L.Debugf("Event tag %v", event.Tag)

	//we need to parse the original json and just get the initial data property
	index := strings.Index(jsonString, `"data":`)
	jsonString = strings.TrimSpace(jsonString)
	jsonSubstring :=
		jsonString[index+7 : len(jsonString)-1]

	if change.MatchString(event.Tag) {
		return translateChange(jsonSubstring)
	} else if becaonStatus.MatchString(event.Tag) {
		return translateBeaconStatus(jsonSubstring)
	} else if chromium.MatchString(jsonString) { //note this one is different - need to look at the raw JSON as well as the tag
		return translateChromium(jsonSubstring)
	} else {
		return ei.Event{}, nerr.Create("Could not translate event! Unrecognized tag.", "UnrecognizedTag")
	}

}

type saltPresenceChangeEvent struct {
	NewItems  []string `json:"new"`
	Timestamp string   `json:"_stamp"`
	LostItems []string `json:"lost"`
}

func translateChange(jsonString string) (ei.Event, *nerr.E) {

	//log.L.Debugf("Identified salt presence/change event: %s", jsonString)
	log.L.Infof("Identified salt presence/change event: %s", jsonString)

	//unmarshal into the event structure so we can process it
	var event saltPresenceChangeEvent
	err := json.Unmarshal([]byte(jsonString), &event)
	if err != nil {
		log.L.Debugf("Error unmarshaling event into structure [%v] [%v]", jsonString, err.Error())
		return ei.Event{}, nerr.Create("Could not translate event! Error unmarshaling.", "UnrecognizedJSON")
	}

	hostname, _ := os.Hostname()

	t, err := time.Parse("2006-01-02T15:04:05.999999", event.Timestamp)
	if err != nil {
		return ei.Event{}, nerr.Translate(err).Addf("Couldn't parse beacon status timestamp")
	}
	e := ei.Event{
		User:         "",
		Timestamp:    t,
		Key:          "event.Data",
		Value:        fmt.Sprintf("\"lost\": [\"%v\"] \"new\":[\"%v\"]}", strings.Join(event.LostItems, "\",\""), strings.Join(event.NewItems, "\",\"")),
		TargetDevice: ei.GenerateBasicDeviceInfo(hostname),
		//                                             This is just a gross way of getting the room out of the device name
		AffectedRoom: ei.GenerateBasicRoomInfo(fmt.Sprintf("%s-%s", strings.Split(hostname, "-")[0], strings.Split(hostname, "-")[1])),
	}
	e.AddToTags(ei.Heartbeat, ei.AutoGenerated)
	return e, nil

}

type saltBeaconStatusEvent struct {
	Timestamp string               `json:"_stamp"`
	Data      saltBeaconStatusData `json:"data"`
	ID        string               `json:"id"`
}

type saltBeaconStatusData struct {
	Loadavg saltBeaconStatusDataLoadAvg `json:"loadavg"`
	Time    string                      `json:"time"`
}

type saltBeaconStatusDataLoadAvg struct {
	OneMin     float32 `json:"1-min"`
	FifteenMin float32 `json:"15-min"`
	FiveMin    float32 `json:"5-min"`
}

func translateBeaconStatus(jsonString string) (ei.Event, *nerr.E) {

	log.L.Debugf("Identified salt heartbeat event: %s", jsonString)

	//unmarshal into the event structure so we can process it
	var event saltBeaconStatusEvent
	err := json.Unmarshal([]byte(jsonString), &event)
	if err != nil {
		log.L.Debugf("Error unmarshaling event into structure [%v] [%v]", jsonString, err.Error())
		return ei.Event{}, nerr.Create("Could not translate event! Error unmarshaling.", "UnrecognizedJSON")
	}

	log.L.Debugf("jsonString:[%v], event:[%v]", jsonString, event)

	//hostname, _ := os.Hostname()
	deviceparts := strings.Split(event.ID, "-")
	t, err := time.Parse("2006-01-02T15:04:05.999999", event.Timestamp)
	if err != nil {
		return ei.Event{}, nerr.Translate(err).Addf("Couldn't parse beacon status timestamp")
	}
	e := ei.Event{
		Timestamp: t,
		User:      "",
		Key:       "event.Data",
		Value: fmt.Sprintf("{\"loadavg\": {\"1-min\":%v, \"15-min\":%v, \"5-min\":%v} \"time\":\"%v\"}",
			event.Data.Loadavg.OneMin, event.Data.Loadavg.FifteenMin, event.Data.Loadavg.FiveMin, event.Data.Time),
		AffectedRoom: ei.GenerateBasicRoomInfo(deviceparts[0] + "-" + deviceparts[1]),
		TargetDevice: ei.GenerateBasicDeviceInfo(event.ID),
	}
	e.AddToTags(ei.Heartbeat, ei.AutoGenerated)
	return e, nil

}

type saltProcessChromiumEvent struct {
	Timestamp      string `json:"_stamp"`
	ChromiumBrowse string `json:"chromium-browse"`
	ID             string `json:"id"`
}

func translateChromium(jsonString string) (ei.Event, *nerr.E) {

	//log.L.Debugf("Identified salt ps/chromium event: %s", jsonString)
	log.L.Debugf("Identified salt ps/chromium event: %s", jsonString)

	//unmarshal into the event structure so we can process it
	var event saltProcessChromiumEvent
	err := json.Unmarshal([]byte(jsonString), &event)
	if err != nil {
		log.L.Debugf("Error unmarshaling event into structure [%v] [%v]", jsonString, err.Error())
		return ei.Event{}, nerr.Create("Could not translate event! Error unmarshaling.", "UnrecognizedJSON")
	}

	//hostname, _ := os.Hostname()
	deviceparts := strings.Split(event.ID, "-")

	t, err := time.Parse("2006-01-02T15:04:05.999999", event.Timestamp)
	if err != nil {
		return ei.Event{}, nerr.Translate(err).Addf("Couldn't parse beacon status timestamp")
	}
	e := ei.Event{
		Timestamp:    t,
		User:         "",
		Key:          "chromium-browse",
		Value:        event.ChromiumBrowse,
		TargetDevice: ei.GenerateBasicDeviceInfo(event.ID),
		AffectedRoom: ei.GenerateBasicRoomInfo(deviceparts[0] + "-" + deviceparts[1]),
	}
	e.AddToTags(ei.Heartbeat, ei.AutoGenerated)
	return e, nil
}
