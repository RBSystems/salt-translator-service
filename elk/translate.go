package elk

import (
	"encoding/json"
	"fmt"
	"os"
	"regexp"
	"strings"

	ei "github.com/byuoitav/common/events"
	"github.com/byuoitav/common/log"
	"github.com/byuoitav/common/nerr"
)

type saltEvent struct {
	Tag  string                 `json:"tag"`
	Data map[string]interface{} `json:"data"`
}

//converts salt events to API events
func translate(jsonString string) (ei.Event, *nerr.E) {

	//unmarshal into the generic structure so we can check the tag
	var event saltEvent
	err := json.Unmarshal([]byte(jsonString), &event)
	if err != nil {
		log.L.Debugf("Error unmarshaling event into generic structure [%v] [%v]", jsonString, err.Error())
		return ei.Event{}, nerr.Create("Could not translate event! Error unmarshaling.", "UnrecognizedJSON")
	}

	becaonStatus := regexp.MustCompile(`(\/beacon).*(\/status)`)
	chromium := regexp.MustCompile(`(\/beacon).*(\/ps).*(chromium)`)
	change := regexp.MustCompile(`(\/presence)(\/change)`)
	//docker := regexp.MustCompile(`(\/beacon)(\/ps)(docker)`)

	log.L.Debugf("Event tag %v", event.Tag)

	//we need to parse the original json and just get the initial data property
	index := strings.Index(jsonString, `"data":`)
	jsonString = strings.TrimSpace(jsonString)
	jsonSubstring :=
		jsonString[index+7 : len(jsonString)-1]

	if change.MatchString(event.Tag) {
		return translateChange(jsonSubstring)
	} else if becaonStatus.MatchString(event.Tag) {
		return translateBeaconStatus(jsonSubstring)
	} else if chromium.MatchString(jsonString) { //note this one is different - need to look at the raw JSON as well as the tag
		return translateChromium(jsonSubstring)
	} else {
		return ei.Event{}, nerr.Create("Could not translate event! Unrecognized tag.", "UnrecognizedTag")
	}

}

type saltPresenceChangeEvent struct {
	NewItems  []string `json:"new"`
	Timestamp string   `json:"_stamp"`
	LostItems []string `json:"lost"`
}

func translateChange(jsonString string) (ei.Event, *nerr.E) {

	//log.L.Debugf("Identified salt presence/change event: %s", jsonString)
	log.L.Infof("Identified salt presence/change event: %s", jsonString)

	//unmarshal into the event structure so we can process it
	var event saltPresenceChangeEvent
	err := json.Unmarshal([]byte(jsonString), &event)
	if err != nil {
		log.L.Debugf("Error unmarshaling event into structure [%v] [%v]", jsonString, err.Error())
		return ei.Event{}, nerr.Create("Could not translate event! Error unmarshaling.", "UnrecognizedJSON")
	}

	hostname, _ := os.Hostname()

	return ei.Event{
		Hostname:  hostname,
		Timestamp: event.Timestamp,
		Event: ei.EventInfo{
			Type:           ei.HEARTBEAT,
			Requestor:      "",
			EventCause:     ei.AUTOGENERATED,
			Device:         hostname,
			EventInfoKey:   "event.Data",
			EventInfoValue: fmt.Sprintf("\"lost\": [\"%v\"] \"new\":[\"%v\"]}", strings.Join(event.LostItems, "\",\""), strings.Join(event.NewItems, "\",\"")),
		},
		Building: "Multiple",
		Room:     "Multiple",
	}, nil
}

type saltBeaconStatusEvent struct {
	Timestamp string               `json:"_stamp"`
	Data      saltBeaconStatusData `json:"data"`
	ID        string               `json:"id"`
}

type saltBeaconStatusData struct {
	Loadavg saltBeaconStatusDataLoadAvg `json:"loadavg"`
	Time    string                      `json:"time"`
}

type saltBeaconStatusDataLoadAvg struct {
	OneMin     float32 `json:"1-min"`
	FifteenMin float32 `json:"15-min"`
	FiveMin    float32 `json:"5-min"`
}

func translateBeaconStatus(jsonString string) (ei.Event, *nerr.E) {

	log.L.Debugf("Identified salt heartbeat event: %s", jsonString)

	//unmarshal into the event structure so we can process it
	var event saltBeaconStatusEvent
	err := json.Unmarshal([]byte(jsonString), &event)
	if err != nil {
		log.L.Debugf("Error unmarshaling event into structure [%v] [%v]", jsonString, err.Error())
		return ei.Event{}, nerr.Create("Could not translate event! Error unmarshaling.", "UnrecognizedJSON")
	}

	log.L.Debugf("jsonString:[%v], event:[%v]", jsonString, event)

	hostname, _ := os.Hostname()
	deviceparts := strings.Split(event.ID, "-")

	return ei.Event{
		Hostname:  hostname,
		Timestamp: event.Timestamp,
		Event: ei.EventInfo{
			Type:         ei.HEARTBEAT,
			Requestor:    "",
			EventCause:   ei.AUTOGENERATED,
			Device:       event.ID,
			EventInfoKey: "event.Data",
			EventInfoValue: fmt.Sprintf("{\"loadavg\": {\"1-min\":%v, \"15-min\":%v, \"5-min\":%v} \"time\":\"%v\"}",
				event.Data.Loadavg.OneMin, event.Data.Loadavg.FifteenMin, event.Data.Loadavg.FiveMin, event.Data.Time),
		},
		//i'm making some assumptions here about the id
		Building: deviceparts[0],
		Room:     deviceparts[0] + "-" + deviceparts[1],
	}, nil
}

type saltProcessChromiumEvent struct {
	Timestamp      string `json:"_stamp"`
	ChromiumBrowse string `json:"chromium-browse"`
	ID             string `json:"id"`
}

func translateChromium(jsonString string) (ei.Event, *nerr.E) {

	//log.L.Debugf("Identified salt ps/chromium event: %s", jsonString)
	log.L.Debugf("Identified salt ps/chromium event: %s", jsonString)

	//unmarshal into the event structure so we can process it
	var event saltProcessChromiumEvent
	err := json.Unmarshal([]byte(jsonString), &event)
	if err != nil {
		log.L.Debugf("Error unmarshaling event into structure [%v] [%v]", jsonString, err.Error())
		return ei.Event{}, nerr.Create("Could not translate event! Error unmarshaling.", "UnrecognizedJSON")
	}

	hostname, _ := os.Hostname()
	deviceparts := strings.Split(event.ID, "-")

	return ei.Event{
		Hostname:  hostname,
		Timestamp: event.Timestamp,
		Event: ei.EventInfo{
			Type:           ei.HEARTBEAT,
			Requestor:      "",
			EventCause:     ei.AUTOGENERATED,
			Device:         event.ID,
			EventInfoKey:   "chromium-browse",
			EventInfoValue: event.ChromiumBrowse,
		},
		Building: deviceparts[0],
		Room:     deviceparts[0] + "-" + deviceparts[1],
	}, nil
}
